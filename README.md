# STM32 Embedded Project Template
Template repo for STM32(H7) projects on the team. Based on [Processor 2025 Firmware](https://github.com/waterloo-rocketry/cansw_processor_canards). It includes a unit test framework and pipeline.

## READ FIRST: How to customize this template
1. Inside `.devcontainer/Dockerfile`, edit the following: 

- `ENV BOARD_NAME="<board_name>"` e.g. "proc
- `ENV STM_DEVICE="<chip_family>"` e.g. STM32H750xx
- `ENV STM_DEVICE_EXACT="<chip_model>"` e.g. STM32H750ZBTX

2. Open STM32CubeMX and generate the .ioc file for your specific chip **in a temporary location**. Make sure you set the following:
- Under `Project Manager`->`Project`
  - Project Name - whatever you want, be consistent
  - Application Structure -> Advanced, leave "Do not generate the main" **unchecked**
  - Toolchain -> STM32CubeIDE, **check** "Generate Under Root"

- Under `Project Manager`->`Code Generator`
  - Select "Copy only the necessary files"
  - Check all 4 boxes under "Generated files"
  - Leave everything else unchanged

-  Under `Pinout & Configuration`, two peripherals need to be enabled by default. These are FDCANx, which interfaces with canlib, and UART4, which interfaces with our custom `printf` library. If your board does not use one or both of these libraries, you will need to update CMake to not look for them.
   - The FDCAN handle is passed to canlib at init, so you can use any one (the HAL sources will generate reagrdless)
   - The UART4 handle is hard coded into `/workspaces/stm32_template/src/third_party/printf/printf.c`, line 269, and simply needs to be changed to match the UART you want to use. It is hardcoded so that you can printf from anywhere without needing to confirm your printf was initialized every time.

3. Replace `PLACEHOLDER.ioc` in the root directory with your ioc file
4. Open the ioc in CubeMX from the new location, and generate code

## Project Structure
- `src/drivers/`: custom peripheral driver modules
- `src/application/`: high-level application logic modules
- `src/third_party/`: third-party libraries
- `src/common/`: shared resources specific to this project
- `tests/`: everything for [testing](#Unit-Testing)
- Everything else is autogenerated by STM32CubeIDE with few modifications

## Developer Setup
This project is not dependent on STM32CubeIDE.
Code editing, unit testing, and building should be done in the devcontainer.
Only running/debugging on target should be done in STM32CubeIDE.

#### 1. Clone repo
- Clone repo and initialize submodules: ```
   git clone --recurse-submodules https://github.com/waterloo-rocketry/cansw_processor_canards ```
   - (Note: if you choose to clone with ssh instead, you have to manually setup ssh forwarding in the devcontainer.)

#### 2. Open project in devcontainer
The devcontainer has everything setup for editing, unit testing, and building. Most dev work should occur in it.
- Open the project using vscode devcontainers.
  - [Install devcontainers](https://code.visualstudio.com/docs/devcontainers/tutorial)
  - In a new vscode window, use `Ctrl+Shift+P`, search `Dev Containers: Open Folder In Container...`, then select this project folder
    - The first time opening the project will take several minutes to build the devcontainer. Subsequent times will be instant.

#### 3. Build and test project in devcontainer
*Recommended: use vscode cmake plugin:*
- Open the CMake plugin tab from the sidebar
- Under `Configure`, select which build type you want
- Hover over `Build`, click the build icon to build the configuration
  - The build preset should automatically be selected (eg, `Build Firmware (Debug) preset`)

#### 4. Run/debug in STM32CubeIDE
STM32CubeIDE is required for flashing/debugging on hardware. NOTE: STM32CubeIDE is not able to *build* this project. STM32CubeIDE is only used to *flash* the build from step 3.
- Import the project into STM32CubeIDE (version 1.16.1 recommended): `File -> Import... -> Existing Projects into Workspace`
- Build the project firmware binary using vscode (step 3)
- Use an ST-Link programmer to connect to processor board.
- Use STM32CubeIDE launch/debug as usual
  - NOTE: since the project can't be built in STM32CubeIDE, auto-building before launch is turned off. **Remember to always build the project after making edits.**

## Unit Testing
We use GoogleTest and Fake Function Framework (fff) for unit testing. All testing-related files are in `tests/`.
- Tests are built from `tests/CMakeLists.txt` which is separate from the project's main build config. Building and running tests is done via cmake.
- Test source code should be written in `tests/unit/`.
- Mocks should be made with fff in `tests/mocks/`.

### Add a test
- Add a new test group file in `tests/unit/`. See `test_dummy.cpp` for example of test structure.
- Add the test group to the cmake build system by editing `tests/CMakeLists.txt`:
  - At the bottom of the file, add the new test group using the `add_test_group()` helper.
    (Read the comments + existing examples explaining how it works)

### Add a mock
We do not include the STM32 HAL library nor FreeRTOS when compiling the project for unit tests.
So if a source file uses a HAL or FreeRTOS file, those files and their functions must be mocked using fff.
This works similarly for mocking other proc modules that a test interacts with but doesn't test.

Example 1:
- `src/drivers/gpio/gpio.c` uses FreeRTOS semaphores via `#include "semphr.h`.
  - In the actual firmware, the real `semphr.h` is included when compiling. But for unit tests, the real `semphr.h` is not included when compiling. So, the unit tests fail to compile (it can't find a `semphr.h` file).
    - To correct this we add a "fake" `semphr.h` in `tests/mocks/semphr.h`. All files in this folder are included when compiling unit test, so the tests now compile.
  - The gpio code uses functions from the real `semphr.h` like `xSemaphoreTake()`. These don't exist in our fake `semphr.h` yet.
    - To correct this we need to create a mock `xSemaphoreTake()` function using fff.
      [fff's Readme](https://github.com/meekrosoft/fff?tab=readme-ov-file#hello-fake-world) describes how to create fake functions. Here's the mock for `xSemaphoreTake()`:
      ```
      // The func to mock: BaseType_t xSemaphoreTake(SemaphoreHandle_t arg0, TickType_t arg1)
      
      DECLARE_FAKE_VALUE_FUNC(BaseType_t, xSemaphoreTake, SemaphoreHandle_t, TickType_t);
      ```
      First we put the *declaration* (`DECLARE_FAKE...`) in `mocks/semphr.h`. Then, put the actual *definition* (`DEFINE_FAKE...`) in the corresponding `mocks/semphr.c`.
- Now in the gpio tests, we can access the mocked semaphore functions via fff to test that the gpio code uses semaphores correctly.

Example 2:
- `src/application/estimator/estimator.c` takes input from flightphase via `#include "application/flight_phase/flight_phase.h`.
  - To test estimator, we will test various inputs from flightphase. But we don't want to be testing flightphase at the same time.
    So, mock flightphase.
  - The real `flight_phase.h` header is built in unit tests, but the source file `flight_phase.c` is not.
    - Since a function *declaration* for `get_flight_phase()` exists in the header, we can use fff's `DEFINE_FAKE...` to create a
      fake *definition* of that `get_flight_phase()`. That definition should be in the test .cpp file, or in the mocks folder if it's applicable for wider use.
    - (Note: unlike example 1 where the header isn't included in unit tests, the flightphase header is included so it doesnt need a `DECLARE_FAKE...`)

### Run/debug tests
- Build in vscode using cmake (see step 3 above)
  - The default `Build Unit Tests With Coverage preset` also automatically runs all tests and generates coverage report.
  - View the coverage report html pages in `build/test/coverage_report` in a local browser
- Use the vscode cmake `Launch` and `Debug` tabs to run/debug individual test groups (cmake shows the available test groups)


## Debugging on hardware
- Use STM32CubeIDE debugging as directed above
- The ST-link programmer has a serial output so you can listen to uart4 from a laptop COM port. The printf library (NOT THE STDLIB PRINTF) is configured to print strings to that COM port. Use `printf_("string to print..")` - note the `_` character.
  - This should rarely be used. Please instead learn how to use the debugger (breakpoints, dynamic print breakpoints, step, etc) for efficient and pleasant debugging.

## Code Standards
This project follows the [team-wide embedded coding standard](https://docs.waterloorocketry.com/general/standards/embedded-coding-standard.html).
- The devcontainer sets up vscode format-on-save to automatically use the team's clang-format.
  - In case you want to format manually, the script can be run from the project root directory:
  ```bash
  ./scripts/format.sh
  ```

- Rocketlib is included at `src/third_party/rocketlib`.
- Developers should be aware of the BARR Standard and make an effort to follow it.

## Adding Log Messages
When adding a new type of data log message, all of the following should be updated:
- src/application/logger/log.h
  - Add a new enum value to `log_data_type_t`:
    ```diff
     typedef enum {
    +    LOG_TYPE_XXX = M(unique_small_integer),
     } log_data_type_t;
    ```
  - Add a struct definition of your message's data fields to `log_data_container_t`:
    ```diff
     typedef union __attribute__((packed)) {
    +    struct __attribute__((packed)) {
    +        uint32_t l;
    +        float f;
    +        // ...
    +    } typename;
     } log_data_container_t;
    ```
- scripts/logparse.py
  - Add a new format spec to the `FORMATS` dict:
    ```diff
     FORMATS = {
    +    M(unique_small_integer): Spec(name, format, [field, ...]),
     }
    ```

## Notes
- Auto-gen stm32 files used STM32CubeMX Version: 6.12.1-RC4,
  STM32CubeIDE version 1.16.1
  